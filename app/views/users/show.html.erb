<div class="container">
<br><br>
<div id="graph"><h2><%= @user.user_type.capitalize %> Data</h2></div>
<style>
  path {
      stroke: steelblue;
      stroke-width: 2;
      fill: none;
  }
 
  line {
      stroke: black;
  }
 
  text {
      font-family: Arial;
      font-size: 9pt;
  }
	
	.axis {
	  shape-rendering: crispEdges;
	}

	.x.axis line {
	  stroke: lightgrey;
	}

  .x.axis path {
  	stroke: #000;
  }

	.x.axis .minor {
	  stroke-opacity: .5;
	}

	.y.axis line, .y.axis path {
	  fill: none;
	  stroke: #000;
	}
</style>

<script type="text/javascript">
/* implementation heavily influenced by http://bl.ocks.org/1166403 */

// define dimensions of graph
var m = [80, 80, 80, 80]; // margins
var w = 1000 - m[1] - m[3]; // width
var h = 400 - m[0] - m[2]; // height

// create a simple data array that we'll plot with a line (this array represents only the Y values, X will just be the index location)
var data = [3, 6, 2, 7, 5, 2, 0, 3, 8, 9, 2, 5, 9, 3, 6, 3, 6, 2, 7, 5, 2, 1, 3, 8, 9, 2, 5, 9, 2, 7];

// X scale will fit all values from data[] within pixels 0-w
var x = d3.scale.linear().domain([0, data.length]).range([0, w]);
// Y scale will fit values from 0-10 within pixels h-0 (Note the inverted domain for the y-scale: bigger is up!)
var y = d3.scale.linear().domain([0, 10]).range([h, 0]);
	// automatically determining max range can work something like this
	// var y = d3.scale.linear().domain([0, d3.max(data)]).range([h, 0]);

// create a line function that can convert data[] into x and y points
var line = d3.svg.line()
	// assign the X function to plot our line as we wish
	.x(function(d,i) { 
		// verbose logging to show what's actually being done
		console.log('Plotting X value for data point: ' + d + ' using index: ' + i + ' to be at: ' + x(i) + ' using our xScale.');
		// return the X coordinate where we want to plot this datapoint
		return x(i); 
	})
	.y(function(d) { 
		// verbose logging to show what's actually being done
		console.log('Plotting Y value for data point: ' + d + ' to be at: ' + y(d) + " using our yScale.");
		// return the Y coordinate where we want to plot this datapoint
		return y(d); 
	})
	
	// Add an SVG element with the desired dimensions and margin.
	var graph = d3.select("#graph").append("svg:svg")
	      .attr("width", w + m[1] + m[3])
	      .attr("height", h + m[0] + m[2])
	    .append("svg:g")
	      .attr("transform", "translate(" + m[3] + "," + m[0] + ")");

	// create yAxis
	var xAxis = d3.svg.axis().scale(x).tickSize(-h).tickSubdivide(true);
	// Add the x-axis.
	graph.append("svg:g")
	      .attr("class", "x axis")
	      .attr("transform", "translate(0," + h + ")")
	      .call(xAxis);
  
  graph.append("text")      // text label for the x axis
                .attr("x", 425 )
                .attr("y",  270 )
                .style("text-anchor", "middle")
                .text("Ingredient #");
                
	// create left yAxis
	var yAxisLeft = d3.svg.axis().scale(y).ticks(4).orient("left");
	// Add the y-axis to the left
	graph.append("svg:g")
	      .attr("class", "y axis")
	      .attr("transform", "translate(-25,0)")
	      .call(yAxisLeft);
	      
  graph.append("text")
          .attr("transform", "rotate(-90)")
          .attr("y", -5)
          .attr("x", -110)
          .style("text-anchor", "middle")
          .text("Quantity Left");
	      	
		// Add the line by appending an svg:path element with the data line we created above
	// do this AFTER the axes above so that the line is above the tick-lines
		graph.append("svg:path").attr("d", line(data));
</script>
<div class="row">
  <div class="span7">
    <h1><%= best_in_place @user, :username %>'s page</h1>
    <ul>
    	<h3>Username:</h3>
    	<%= @user.username %>

    	<h3>User type:</h3>
    	<%= @user.user_type %>

    	<h3>Description:</h3>
    	<%= raw @user.description %>

    	<h3>Price Range:</h3>
    	<%= @user.price_range %>
	
	
	  <% if @user.user_type.include?("both")%>
	    <%= render "shared/rest_front" %>
      <%= render "shared/supplier_front" %>
	  <% else %>
      <% if @user.user_type.include?("rest") %>
        <%= render "shared/rest_front" %>
      <% else %>
        <%= render "shared/supplier_front" %>
      <% end %>
    <% end %>
    </ul> 

    <br>
    <% if current_user.id == @user.id %>
    	<p><%= link_to 'Edit Profile', edit_user_path, {:style => "font-size: 35px; color: #728FCE"} %></p>
    <% end %>
    <br>
  </div>
  
  <div class="span5">

    <h1>Friends</h1>
    <ul>
      <% for friendship in @user.friendships %>
        <li>
          <%=h friendship.friend.username %>
          (<%= link_to "remove", friendship, :method => :delete %>)
        </li>
      <% end %>
    </ul>

    <% if current_user.id == @user.id %>
    	<p><%= link_to "Find Friends", users_search_path %></p>
    <% end %>

    <h2>Friended by Users</h2>
    <ul>
      <% for user in @user.inverse_friends %>
        <li><%= user.username %></li>
      <% end %>
    </ul>
      <% if @users.nil? || @users.empty? %>
        You have no friends at this time.
      <% end %>
    </br>
    </br>
    </br>
<!--start of IFP-->
<% if current_user.id == @user.id %>
	<h1>Inward Facing Profile</h1>
	<h2>User->Food</h2>
	<% @user.food.each do |item| %>
		<%= item.fname %><br>
	<% end %>

	<h2>User->Inventory</h2>
	<% @user.inventory.each do |item| %>
		<% item.ingredients.each do |ing| %>
			<%= ing.ingredient_name %>
		<% end %>
		$<%= item.purchase_price %><br>
	<% end %>
<% end %>

<h2>Import Products</h2>
	<%= form_tag import_users_path, multipart: true do %>
	<p>Select a file and press "Import" to import!</p>
 		<%= file_field_tag :file %><br>
		<%= submit_tag "Import", {:class=>'btn'} %>
	<% end %>
<!-- end of IFP-->
</div>
</div>
